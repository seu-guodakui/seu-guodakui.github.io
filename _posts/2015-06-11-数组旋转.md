---
layout: post
title: "坐标和数组的旋转问题"
categories:
- 算法
tags: c语言 算法 图形

---

### 两种坐标旋转类型

在写俄罗斯方块时，需要解决一个点以另一个点为中心进行旋转的问题，开始的时候，我以为只要给出了两个坐标，就可以用统一的规则，但是，当考虑整个图形的旋转时，发现了两种情况：

![](/media/png/tetris_j.png)

![](/media/png/tetris_o.png) 

假设每个方格都是一个像素点（忽略网格），第一幅图，能找到一个中心块，它的坐标不会变，也是旋转中心。

第二幅图，所有方块都会改变坐标，中心是一个点，找不到“中心块”，这种情况下，找不到一个坐标中心，这时候，可以认为中间4块是“中心”，可以选取任何一个块作为中心块，然而算法肯定与图一的不相同了。

分别讨论两种情况，上面两种我称为“奇变换”（边长是奇数）和“偶变换”

### 奇变换

只要在纸上画一下(注意屏幕的x和y轴和普通坐标系的差异)，就能发现若(X0,Y0)是旋转中心，(X1,Y1)是等待旋转坐标，再定义：

dx=X1-X0;  
dy=Y1-Y0;

顺时针旋转则是

	to_x = X0 - dy;
    to_y = Y0 + dx;
逆时针旋转则是

	to_x = X0 + dy;
    to_y = Y0 - dx;
旋转算法其实就是这样很简单，但是，真正的俄罗斯方块每一块不可能只有一个像素点，有时还有网格，就像上两个图，现在假设网格线宽为line_w方块的长宽都为rec_w。图一如果是奇变换，则rec_w必须为奇数（以方块的中心块为中心块），图二如果是奇变换，则line_w必须为奇数（以线的中心块为中心块），如果想让两个图用相同的规则旋转，就必须让rec_w和line_w都是奇数。另外，旋转规则相应的改为

	to_x = X0 - dy - (rec_w - 1);
    to_y = Y0 + dx;
和

	to_x = X0 + dy;
    to_y = Y0 - dx - (rec_w - 1);
关于这里为什么要 - (rec_w - 1)，看下图，a点被转换到了b点，但是c点才是表示那一块的左上角坐标。

![](/media/png/tetris_j_sz.png)

最后是一个显然的结论，若顺时针旋转n次，等价于逆时针旋转（4-n）次。
### 偶变换
 
偶变换，我发现把中心的四块各取中心，构成成一个虚拟的“中心块”，就可以构成奇变换的模型了，但是这一块的坐标是实际上的不存在的(x.5)这样的小数性质，再进一步分析，把中心点的计算也算起进来，并不包含浮点数，最后才发现，自己真是太傻逼了！如果不使用“中心点”来旋转，而是直接把整个正方形拿来旋转，那么奇变换和偶变换是可以统一起来的！问题也会变得非常简单。都怪我一直盯着“旋转中心”这种东西不放。

### 通用方法，放到某个正方形中旋转

先把正方形放到(0,0)处，这样就不用考虑正方形的起始坐标了，旋转完成后再平移回去就好了。假设放入的正方形的边长为L+1,用L+1的话，L就是正方形最右坐标和最左坐标之差(x2-x1)。顺时针旋转就是

	to_x = L - Y0;
    to_y = X0;
逆时针就是

	to_x = Y0;
    to_y = L - X0;
就是这样简单啊，有了这个，实际的俄罗斯方块就不难了(知道L和正方形左顶点坐标)，假设要旋转的正方形坐标（sx，sy），(L+1)为宽，rec_w为俄罗斯方块基本块的宽。现有坐标(X0,Y0)顺时针旋转后为：

	to_x = L -(Y0 - sy) + sx - (rec_w -1)//原因见第三个图
	to_y = (X0 - sx) +sy
逆时针就是

	to_x = (Y0 - sy) +sx
    to_y = L -(X0 - sx) + sy - (rec_w -1)
### 数组的旋转

数组的旋转方法和上面通用方法是一样的规律，注意二维数组的两个下标，哪个是x哪个是y。写个测试：

{% highlight c %}

#include <stdio.h>
#include <stdlib.h>

//输出二维数组的函数
void printarr(void **arr,int h,int w)
{
    for(int i=0;i<h;i++)
    {
        for(int j=0;j<w;j++)
        {
            printf("%d ",*((int *)(arr+i*sizeof(int))+j));
        }
        printf("\n");
    }
}

int main(void)
{
    int arr[4][4]={
    1,4,5,2,
    4,7,9,4,
    5,0,0,2,
    5,6,0,8,
    };
    int sz[4][4];
    int L=3;//宽度 - 1
    for(int i=0;i<4;i++)
    {
        for(int j=0;j<4;j++)
        {
            //关键部分
            sz[j][L-i]=arr[i][j];
        }
    }
    printarr(sz,4,4);
    return 0;
}
{% endhighlight %}
